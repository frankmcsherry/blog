## Understanding E-Graphs

This is a work in progress, as I try and further understand [e-graphs](https://en.wikipedia.org/wiki/E-graph).

I was introduced to e-graphs a while ago, and while they seemed tasty at the time, I did not fully understand either their benefits, or their implementations.
In learning more about them, they both more interesting and less complicated than I initially thought.
However, I took a slightly different path than the papers I read, and I thought sharing that might help you as it has me.

First, I'm largely drawing from the [egg paper](https://dl.acm.org/doi/10.1145/3434304), which you can find among other helpful resources on the [egg website](https://egraphs-good.github.io).
Egg is among other things a Rust implementation of e-graphs, but also a fairly clear and clarifying presentation of the concepts.
I recommend you start there, especially if in reading what follows you worry that I may have botched it all.
Secondly, my implementation is the result of a few days of typing, and likely has innumerable defects.

We'll tell the story through a bit of code review, where I show off what I've written (a few hundred lines of Rust).

### For Starters: An Abstract Language

E-graphs are about representing information about expressions in abstract languages.
We'll need one of these languages to get started.
I'm going to use a concrete one for presentation, but one of the points of `egg` is that it is generic over your choice of language.
The only thing you need to point out is how many arguments each operator in your language requires, which we'll do with a trait:
```rust
/// A type that requires inputs and produces an output.
pub trait Function {
    /// The number of inputs the function requires.
    fn inputs(&self) -> usize;
}
```

We'll use a simple expression language, chosen mostly to be able to get through the worked example in the egg paper.
There are a few binary operators, as well as literal integers, and placeholders for variables.
```rust
#[derive(Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]
enum Op { Add, Mul, Div, Shf, Lit(i32), Var(i32), }

impl Function for Op {
    fn inputs(&self) -> usize {
        match self {
            Op::Add | Op::Mul | Op::Div | Op::Shf => 2,
            Op::Lit(_) | Op::Var(_) => 0,
        }
    }
}
```

We'll think about expressions as pre-order sequences of `Op`.
For example, we could represent the expression `(a x 2) / 2` as:
```rust
[Op::Div, Op::Mul, Op::Var(0), Op::Lit(2), Op::Lit(2)]
```
You can also think about putting these into expression trees, if that appeals to you.
Each tree node would have an `Op` and a list of other tree nodes for their inputs.
We won't be doing that.

We could write a parser and evaluator and such for this language, but we won't.
At least, not yet, because they are not an essential part of understanding e-graphs.

### Introducing E-Graphs

An e-graph is a compact way to represent "equivalence" information between expressions.
Our expression above, `(a x 2) / 2`, is equivalent to the expression `a`.
But, how might we both figure that out and represent it, efficiently?

An e-graph is comprised of equivalences classes, called e-classes.
An e-class contains a number of equivalent e-nodes.
An e-node is a pair of an operator and a list of e-class identifiers as arguments.

An expression (a sequence of operators) can be located in an e-graph by repeatedly replacing its operators with their e-class identifiers, starting at the back end and working forwards (or "up the tree", if you prefer trees).

Here are the types I'll be using, building up the complexity from identifiers, to e-nodes, to e-classes, to e-graphs.
```rust
/// An e-class identifier.
pub type Id = usize;

/// An operator, and a list of e-class identifiers for arguments.
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]
pub struct ENode<T> {
    pub op: T,
    pub args: Vec<Id>,
}

/// An equivalence class of e-nodes, and references to this class.
#[derive(Clone, Debug)]
pub struct EClass<T> {
    /// A list of e-nodes that map to this e-class.
    pub members: BTreeSet<ENode<T>>,
    /// A list of e-nodes that reference this e-class.
    pub parents: BTreeSet<ENode<T>>,
}

#[derive(Clone, Debug)]
pub struct EGraph<T> {
    /// A map from e-nodes to their e-class.
    pub nodes: BTreeMap<ENode<T>, Id>,

    /// For each e-class, lists of class members and class parents.
    pub classes: BTreeMap<Id, EClass<T>>,

    /// A list of pending merge requests.
    pub pending: Vec<(Id, Id)>,
}
```

The `EClass` struct has `members`, as advertised, but also a `parents` list.
The `EGraph` struct has `classes`, as advertised, but also `nodes` and `pending`.
What are all of these additional fields?

I am happiest thinking of the `EGraph` as completely determined by the `nodes` member, which maps e-nodes to their e-class identifier.
This fully describes the information of the e-graph.
The `classes` member is a *view* over the `nodes` member: it tracks each *reference to* an e-class identifier.
This view contains references both from `nodes` (the "members") as well as from references in the arguments of e-nodes (the "parents", because those e-nodes have the e-class as inputs).

The `pending` member is an implementation detail that allows us to perform egg's deferred merging.
You'll see!
The impressive thing, from my point of view, is that this is all you need to implement an e-graph.
We will add some more moving parts, but these are the type definitions I'm using.
Egg adds some more derived indexes, e.g. from `Op` to `Id` for e-classes containing each operator, but still derived data from `nodes`.

### Working with E-Graphs

What might you do with an e-graph?

Here are the methods I've implemented, with the details hidden for the moment.
We'll investigate them in turn, unpackaging the complexity in smaller bites.
```rust
impl<T: Function + Ord + Clone> EGraph<T> {
    /// Introduces the equivalence of two expressions.
    pub fn equate(&mut self, e0: Vec<T>, e1: Vec<T>) {
        let id0 = self.insert(e0);
        let id1 = self.insert(e1);
        self.merge(id0, id1);
    }

    /// Adds an expression to the e-graph.
    ///
    /// The `expr` argument is expected to be in pre-order.
    pub fn insert(&mut self, mut expr: Vec<T>) -> Id {
        unimplemented!()
    }

    /// Requests a merge of two e-classes.
    pub fn merge(&mut self, a: Id, b: Id) {
        self.pending.push((a, b));
    }

    /// Applies all pending merges, and restores invariants.
    pub fn refresh(&mut self) {
        unimplemented!()
    }

    /// Attempts to minimize `expr` using equivalences.
    pub fn extract(&self, expr: &mut Vec<T>) {
        unimplemented!()
    }
}
```

There are a rich variety of related methods you might want, for example perhaps because my demo-ware test harness didn't try to do anything too real.
For example, it is natural to want a non-inserting `find` method, though I only ended up needing this in some pattern matching code, which couldn't use a general implementation.

But roughly, the idea is that you might start from a fresh e-graph, insert some expression you are interested in, and then apply equivalences that match your understanding.
Here's an example:
```rust
    // (a x 2) / 2
    let eggsample = vec![Op::Div, Op::Mul, Op::Var(0), Op::Lit(2), Op::Lit(2)];
    let mut e_graph: EGraph<Op> = Default::default();
    e_graph.insert(eggsample.clone());
    
    // a x 2 == a << 1
    e_graph.equate(
        vec![Op::Mul, Op::Var(0), Op::Lit(2)],
        vec![Op::Shf, Op::Var(0), Op::Lit(1)],
    );
    // (a x 2) / 2 == a x (2 / 2)
    e_graph.equate(
        eggsample.clone(),
        vec![Op::Mul, Op::Var(0), Op::Div, Op::Lit(2), Op::Lit(2)],
    );
    // 2 / 2 == 1
    e_graph.equate(
        vec![Op::Div, Op::Lit(2), Op::Lit(2)],
        vec![Op::Lit(1)],
    );
    // a x 1 == a
    e_graph.equate(
        vec![Op::Mul, Op::Var(0), Op::Lit(1)],
        vec![Op::Var(0)],
    );
    // Refresh the e-graph to reflect equated terms.
    e_graph.refresh();
```

This is a worked example from the egg paper, where the narrative arc is that while swapping out `a x 2` for `a << 1` feels smart, it is even smarter to keep the `x 2` around to cancel the `/ 2`.
When you introduce each of these equivalences (egg also *finds* the equivalences; more on that later), you end up with four equivalence classes:
```
ENode (Mul [8, 0]) -> EClass #2
ENode (Mul [8, 6]) -> EClass #8
ENode (Div [0, 0]) -> EClass #6
ENode (Div [2, 0]) -> EClass #8
ENode (Shf [8, 6]) -> EClass #2
ENode (Lit(1) [])  -> EClass #6
ENode (Lit(2) [])  -> EClass #0
ENode (Var(0) [])  -> EClass #8
```
This might actually be a good moment to see if you can read e-graph.

Our `a` term is `Var(0)`, found in e-class `8`.
Also in `8` is `Div [2, 0]`, which it turns out is the root of our inserted `eggsample` expression.
You can see this by following e-classes `2` and `0`.
E-class `2` contains `Mul [8, 0]`, where `8` contains `a` and `0` contains `Lit(2)`; this is the numerator in our expression.
E-class `0` contains `Lit(2)` which is the denominator of our expression.

There are several other e-nodes in here, like `Lit(1)` and `Div [0, 0]`, which play a role in going from `(a x 2) / 2` to the much simpler `a`.
I say going to "the much simpler `a`" but I didn't actually call `e_graph.extract(&eggsample)`, which is because I haven't written it yet.
Let's look at the methods I did write, instead.

#### Inserting in to E-Graphs

Insertion of an expression into an e-graph isn't all that hard!

Recall that an expression is a sequence of operators, in pre-order.
We would be able to evaluate the expression by starting at the end and working forwards.
Instead, we are going to "evaluate" the e-class identifier of the terms, in the same manner.
Starting at the end of the expression, or leaves of the tree if you prefer, we'll treat each operator as if it is an e-node, with e-class id arguments.
We'll look up that e-node, "evaluating" it, and produce the e-class id as the output.
In the case that we don't find the e-node, we'll create a new singleton e-class and insert it.

```rust
/// Adds an expression to the e-graph.
///
/// The `expr` argument is expected to be in pre-order.
pub fn insert(&mut self, mut expr: Vec<T>) -> Id {
    // Repeatedly pop the tail of `expr` and the inserted `args`,
    // to find that e-node in `self.nodes` and push that e-class id.
    let mut ids = Vec::new();
    while let Some(op) = expr.pop() {
        let inputs = op.inputs();
        let args = &ids[ids.len() - inputs..];
        let e_node = ENode::new(op, args.iter().cloned().rev().collect());
        // We may find the e-node, or we may not.
        if let Some(id) = self.nodes.get(&e_node) {
            ids.truncate(ids.len() - inputs);
            ids.push(*id);
        }
        else {
            // 1. Add `e_node` to parents of each element of `args`.
            for e_class in args.iter() {
                self.classes
                    .get_mut(e_class)
                    .unwrap()
                    .parents
                    .insert(e_node.clone());
            }
            // 2. Form a new e-class with `e_node` as its only member.
            let e_class = EClass {
                members: BTreeSet::from([e_node.clone()]),
                parents: Default::default(),
            };
            let new_id = self.new_id();
            self.classes.insert(new_id, e_class);
            // 3. Add `e_node` to `self.nodes`.
            self.nodes.insert(e_node, new_id);
            ids.truncate(ids.len() - inputs);
            ids.push(new_id);
        }
    }
    // The last step of each branch above is to push into `ids`.
    ids.pop().unwrap()
}
```

Although a bit fiddly, what with the order of arguments and such, the implementation isn't too complicated, to my eyes.
The main risk is when adding an e-node: care must be taken to set all invariants correctly, especially around how `self.classes` is meant to mirror `self.nodes`.
This code would need to change were any other views and indexes over `self.nodes` introduced.

You may have noticed above, but this also gives us our `EGraph::equate` implementation as well.
If you scroll up, it inserts its two arguments, and then enqueues a merge between them.
That merge request just goes in to a list, where it sits until someone calls `EGraph::refresh`.
Let's dive in to that next!

#### Refreshing E-Graphs

One of the contributions of the egg work is that e-graphs may defer their merging work.
This allows them to spend a decent amount of time thinking about what to merge, and to then perform the merges in batch.
The batch updates end up more efficient, as a fair bit of redundant work can be eliminated.

What is all the work that needs to be done?

There are two main things that need to happen when merges are processed:

1.  Any merged e-classes must now be part of the same e-class. 
    There can be many merges, so this looks a lot like a graph connectivity problem.
    Each connected component of merged e-classes become one e-class.
2.  E-nodes that reference any merged e-class may need to update their identifiers.
    Fortunately, all e-class references are tracked by the e-class itself, so these are easy to find.
3.  E-nodes that update identifiers may find they collide with other updated e-nodes when re-inserted into `self.nodes`.
    These e-nodes were not necessarily part of an e-class that merged, but their e-classes should now merge (this is good news!).
    This prompts more merging work that must be completed before the congruence invariant is restored.
    
We'll structure our approach as a loop that applies these steps in order, repeatedly, until there is no pending merge work to do.
```rust
/// Applies all pending merges, and restores invariants.
pub fn refresh(&mut self) {

    while !self.pending.is_empty() {
```

That first part is always the easiest to write.

The next step is to identify the connected components of e-classes that must merge.
We use [union-find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) for this, but any undirected connectivity algorithm should work.
It just turns out I've forgotten how to write anything other than union-find.
Also, I forgot how to write union-find, and had to read the wikipedia page to get it correct.

```rust
        // Plan out all merges from pending using union-find.
        // The `union` and `find` methods are in a helper trait, elsewhere.
        let mut uf = BTreeMap::new();
        for (a, b) in self.pending.iter().copied() {
            uf.union(&a, &b);
        }
        // Force each identifier to point at its component id.
        // Union-find doesn't usually do this in `find`, but mine does.
        for (a, b) in self.pending.drain(..) {
            uf.find(&a);
            uf.find(&b);
        }
        // Form each group, as a map from id back to a list of member ids.
        let mut new_classes = BTreeMap::new();
        for (a, b) in uf.iter() {
            new_classes.entry(*b).or_insert_with(Vec::new).push(*a);
        }
```

The `uf` map allows us to correct any e-class identifier to a new shared identifier.
The `new_classes` map now has our lists of e-class identifiers to merge.
The next step is doing something with those lists, namely writing down all the affected e-nodes, who must update their identifiers.

```rust
        // Track e-nodes that must refresh, and remove all merged e-classes.
        // We will rebuild the e-classes as we refresh the e-nodes.
        let mut refresh = BTreeSet::new();
        for (_id, class) in new_classes {
            for e_class in class {
                let e_class = self.classes.remove(&e_class).unwrap();
                refresh.extend(e_class.members);
                refresh.extend(e_class.parents);
            }
        }
```

We totally removed the merged e-classes, and only wrote down the e-nodes that were present in them.
We will rebuild the merged class as part of updating the identifiers; recall that the information is a view over `self.nodes`, and we can rebuild it.
Egg saves some time by not doing this work for the e-class whose identifier we end up using for each merge, but it seemed like something I would get wrong.
I do think you need to do this, specifically preserving the identifier of the largest e-class, to avoid quadratic behavior, so I should probably get on that.

The next step, last in each iteration, is to update all of the e-nodes.
This isn't too hard, conceptually.
We remove all references to the old e-nodes, update them, and then insert all references to the new e-nodes.
While re-inserting into `self.nodes`, we may find the node already present (!!), which requires that we schedule a merge between those two e-classes.

```rust
        // Refresh e-nodes; remove evidence of their old self, introduce them
        // to the e-classes they now reference. Should any refreshed e-nodes
        // match, but with different e-class identifiers, merge those e-classes.
        for mut e_node in refresh {
            // Extract the stale e-node and its e-class.
            let mut id = self.nodes.remove(&e_node).unwrap();
            // Remove evidence of the stale e-node.
            if let Some(e_class) = self.classes.get_mut(&id) {
                e_class.members.remove(&e_node);
            }
            for arg in e_node.args.iter() {
                if let Some(e_class) = self.classes.get_mut(arg) {
                    e_class.parents.remove(&e_node);
                }
            }
            // Update the e-classes referenced by the e-node.
            if let Some(new) = uf.get(&id) {
                id = *new;
            }
            for arg in e_node.args.iter_mut() {
                if let Some(id) = uf.get(arg) {
                    *arg = *id;
                }
            }
            // Introduce evidence of the refreshed e-node.
            self.classes.entry(id).or_default().members.insert(e_node.clone());
            for arg in e_node.args.iter() {
                self.classes.entry(*arg).or_default().parents.insert(e_node.clone());
            }
            // Re-add the e-node to `self.nodes`, and enqueue a merge if necessary.
            if let Some(other) = self.nodes.insert(e_node, id) {
                if other != id {
                    self.pending.push((other, id));
                }
            }
        }
```

And with that, we are done with the loop body!
The only thing left to do is go around the loop until we run out of `self.pending`.
As we only ever merge e-classes, and always merge at least one e-class, the loop must eventually terminate.

```rust
    }
}
```

That's the whole thing.
E-graphs accomplished!
I guess there was another method
```rust
    /// Attempts to minimize `expr` using equivalences from the e-graph.
    pub fn extract(&self, _expr: &mut Vec<T>) {
        unimplemented!()
    }
```

Yeah, I haven't done it yet.
There is fairly straight-foward iterative algorithm that establishes tentative representatives for each e-class, and then iteratively improves them by re-considering e-classes with e-nodes that references any changed representative.
I did code this up, but I haven't gotten as far as rewriting `_expr` as the signature requires.

### Searching E-Graphs

As interesting as it is to manually introduce equivalences like `(a x 2) / 2 == a x (2 / 2)`, the e-graph community has concluded that humans should not be involved in effecting these rules.
The reason the rule is appropriate is because of the more general `(a x b) / c == a x (b / c)`, and it happened that `b = c = 2` in our case.
But how do we start from general rules and automatically find application targets?

It turns out this is a neat instance of [graph motif](https://en.wikipedia.org/wiki/Network_motif) finding.
Our equality up above is looking for matches of the form `[Div, Mul, v0, v1, v2]`, where the `v` terms are variables we would like to bind.
Our e-graph is a giant labeled graph, where e-classes reference e-nodes that reference operators and other e-classes.
There are a lot of interesting algorithms for finding motifs in graphs; you might remember that [I used to do this a long time ago](https://github.com/frankmcsherry/blog/blob/master/posts/2016-09-17.md).

The tippy-top best ways to do this are various forms of [worst-case optimal join](https://en.wikipedia.org/wiki/Worst-case_optimal_join_algorithm), one of the best things to come out of the databases community in the past decade or so.
These are approaches to implementing joins, as it turns out graph motifs are well describe by, that avoid massively exploding the data only to find no results.
They have a slightly different flavor than most join algorithms you know about, and I won't be able to explain them fully here.

But we can talk through a *bad* implementation of pattern matching!

When given a pattern like `[Div, Mul, v0, v1, v2]` one approach is to bind the variables in turn, and cease exploring some bindings when you find a conflict.
For example, we could try all values of `v0`, and bail out on any values that couldn't possibly be solutions.
For our example, all e-classes except `8` would be failures, because none of the other e-classes have a `Mul` that references them.
Continuing with `8`, we would find that both e-classes `0` and `6` participate in a `(Mul, [8, _])` e-node.
Continuing with both `[8, 0]` and `[8, 6]` we would find that only e-class `0` divides such a term.
This gives us the only binding, `[8, 0, 0]`, which corresponds to `(a x 2) / 2`.

I implemented .. a worse version of this.

There are many other ways to propose and prune extensions.
For example, if you want to do constant folding, you only need to start in e-classes that contain literals, and look at their parents to find e-nodes that could possibly be evaluated.
Egg maintains a map from operators to e-classes so that they can quickly investigate e-classes that might match their operators.

More generally, worst-case optimal joins have a class of algorithms based on *proposers* and *validaters*.
For each variable `v`, any number of constraints may exist on it, and you pick the constraint that can *propose* the fewest candidates.
Each other constraint validates each candidate, and any that survive all valiations are accepted.

There is an art to getting the data in the right shape that these proposals are fast.
This is exactly where treating `EGraph::nodes` as a source of truth, and various other collections as derived views pays off.
The `EGraph::classes` collection is a view over `nodes`, set up to provide fast random access.
Similarly, egg's `classes_by_op` is an index by operator to find classes that reference them.
Any other number of indexes are potentially available!