# Programming with time in Materialize

Materialize provides a `mz_now()` function that returns the current time from Materialize's point of view.
This is very similar to PostgreSQL's `now()` function, which provides the time at the start of a transaction.
Unlike `now()`, Materialize is able to incrementally maintain some views that use `mz_now()`, subject to some constraints.

These constraints are at times mysterious, and this post works through some of the challenges and the work arounds.

The constant tension with `mz_now()` in maintained views is that .. it changes so much.
Every millisecond `mz_now()` takes on a new value, and this introduces a great deal of stress for Materialize, which works by chasing down changes that have occurred and seeing what their implications are.
The "art" to using `mz_now()` comes down to finding the fewer, discrete moments where you would like your maintained view to change, and re-framing your logic to reveal this.
We'll do this a few different ways, to get a rough feel for it.

## Temporal Filters

The primary use of `mz_now()` in maintained views is in `WHERE` and `HAVING` clauses.
Materialize calls these uses "temporal filters", as the filtering happens in part as a function of time, not only of the record data.

Here's an example clause that shows how to retain records in a `row` table from some `insert_ms` until some `delete_ms`, recorded in the row itself.
```sql
WHERE mz_now() BETWEEN row.insert_ms AND row.delete_ms
```

There are some light caveats, but it's best to remember that it is as if Materialize continually re-evaluates your SQL, moment by moment.
Mainly, although the expression suggests that a `row` will be present from `insert_ms` onward, it is actually only present from the maximum of this time and the moment the row was actually inserted;
Materialize cannot go back in time and pre-insert the row whenever it has a small `insert_ms`.
This is exactly the same with PostgreSQL or any other OLTP database: you can insert a row with `insert_ms` equal to a year ago, but PostgreSQL still wont show you the row until it is actually inserted.
Each `row` will not be retained past its `delete_ms`, without caveat.

Temporal filters require that `mz_now()` be directly compared to a `numeric` or `timestamp` expression, one that does not containe `mz_now()`, in a `WHERE` or `HAVING` clause (not including the `WHERE` clause in a `FILTER` expression, which is different).
This constraint is important for Materialize to be able to determine how to translate the constraint to somenthing

## Reframing `WHERE` and `HAVING` clauses

Temporal filters ask you to frame your constraints as bounds on `mz_now()`, for example
```sql
WHERE mz_now() BETWEEN tbl.insert_ms AND tbl.delete_ms
```
This describes the times for which each record of `tbl` will participate in the result.

Often it can feel more ergonomic to write constraints instead as
```sql
WHERE tbl.insert_ms > mz_now() - INTERVAL '1 DAY'
```
This framing describes which records you'd like at any moment: those whose insertion happened at most a day ago.
For many users, this is the most natural way to describe the constraint.

This constraint can be rewritten to the nearly identical
```sql
WHERE tbl.insert_ms + INTERVAL '1 DAY' > mz_now()
```
or equivalently
```sql
WHERE mz_now() < tbl.insert_ms + INTERVAL '1 DAY'
```
This framing describes the range of times each record will be valid: for one day past the insert time.
It turns out that this is the information Materialize needs, to determine the future moment when a next update will occur for each record.

The two rewritings are almost identical to the original constraint, just moving the `INTERVAL` to the other side of the inequality.
The rewritings are subtly different though, in that the error behaviors (when subtraction underflows or addition overflows) are not identical.
More complicated operations become progressively harder to invert, for example reversing out timezone manipulation and leap seconds and such.
For these reasons, Materialize doesn't currently perform the rewrite for you automatically.

## Moving `mz_now()` evaluation to ad-hoc `SELECT`s

A classic pattern in logistics is to have a `shipments` view, with `shipped_at` and `received_at` columns.
It's very reasonable to want a view over this that summarizes the shipment delays, including those for shipments that have not yet been received: say those with a null `received_at`.

In ad-hoc SQL you could determine the average with a query like
```sql
SELECT AVG(COALESCE(received_at, now()) - shipped_at)
FROM shipments;
```

Perhaps understandably, this is tricky to *maintain* because it changes every millisecond.
Expensive to maintain, at least.
And generally more expensive than it is valuable.

An alternate way to achieve the same outcome is to break apart the two cases concealed by the `COALESCE`: shipments with and without a `received_at` value.
We will maintain the counts and sums for each of these cases,
```sql
CREATE VIEW complete AS
SELECT COUNT(*) count,
       AVG(received_at - shipped_at) avg
  FROM shipped
 WHERE received_at IS NOT NULL;

CREATE VIEW inflight AS
SELECT COUNT(*) count,
       AVG(shipped_at) avg
  FROM shipped
 WHERE received_at IS NULL;
```
Each of these views can be materialized, and incrementally maintained.
You would need to use `CREATE INDEX` or `CREATE MATERIALIZED VIEW` to cause this to happen.
As shipments come and go, or have their various times updated, the results will exactly track the correct answers.

At query time, it's not too hard to put the results of these queries back together, with the current query time.
```sql
SELECT (complete.count * complete.avg
      + inflight.count * (mz_now() - inflight.avg))
      / (complete.count + inflight.count)
FROM complete, inflight;
```
This query *cannot* be incrementally maintained, because of the `mz_now()` in the `SELECT` columns, but it can be evaluated almost for free.

We partitioned our query into the parts that can be incrementally maintained, and the "finishing" of the results based on the current time.
The moves the work that depends on `mz_now()` to the moments where a user wants to look at it, and avoids attempting to continually update the results every millisecond.

## Providing a clock source, because you need it

Although it's best practices to reduce your incrementally maintained SQL down to the fewest changes possible, there are times when you just need a collection containing the current time that changes every .. so often.

I should stress that I really don't recommend this, and really do recommend investing in getting your head around the discrete moments where your query results change.
Nonetheless, it can be a rite of passage, and potentially an easy unblocker for less complex logic.

We are going to steal from [a previous blog post](https://materialize.com/blog/operational-data-sql/), on how to write load generators using only `mz_now()` and incrementally maintained views.
It might sound odd that we are going to write a clock source, because we cannot use `mz_now()` directly, by using `mz_now()`.
Bear with me!

The rough idea is that we can use a temporal filter applied to the next 100 years, to "incrementally maintain" the current year.
From the current year, we can use a temporal filter to maintain the current month.
From the current month, we can maintain the current day, then the current hour, the current minute, the current second, all the way to the current millisecond.

```sql
-- Each year-long interval of interest
CREATE VIEW years AS
SELECT *
FROM generate_series(
    '1970-01-01 00:00:00+00',
    '2099-01-01 00:00:00+00',
    '1 year') year
WHERE mz_now() >= year
  AND mz_now() < year + '1 year';

-- Build an index to incrementally maintain.
CREATE DEFAULT INDEX on years;
```

This is a view that uses a temporal filter and maintains the current year, as determined by `mz_now()`.
It uses approximately zero resources to maintain.

We can repeat this for days but need to make a few changes, to hold Materialize back.
The first thing we'll need is an empty table, which exists only to restrain Materialize from reading ahead and producing all future clock events through 2099.
```sql
-- Holds back Materialize's reasoning.
CREATE TABLE empty (e TIMESTAMP);
```
The view to go from `years` to `days` uses `generate_series` to produce all days in each input year (the current year only, in this example).
```sql
-- Each day-long interval of interest
CREATE VIEW days AS
SELECT * FROM (
    SELECT generate_series(year, year + '1 year' - '1 day'::interval, '1 day') as day
    FROM years
    UNION ALL
    SELECT * FROM empty
)
WHERE mz_now() >= day
  AND mz_now() < day + '1 day';

-- Build an index to incrementally maintain.
CREATE DEFAULT INDEX ON days;
```
We can repeat this, using the same `empty` table, for hours, minutes, seconds, etc.

It's important to do the various weird things, like using `empty` and creating indexes on each view, to prevent Materialize from reading ahead and attempting to work through all of next year's milliseconds.
We know that it shouldn't get started on those yet, but there isn't a great way in a declarative language like SQL to communicate this (*when* we should do work).

If you repeat all the way down to `seconds` or even `milliseconds`, you should have a table containing a single element that is always the current time to the second, or millisecond.