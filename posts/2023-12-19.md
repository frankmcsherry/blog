## Logistics with Recursive SQL

Let's look at a problem from logistics: computing and then maintaining the most appealing matches between producers and consumers.

Producers make things, or supply services, or are otherwise in demand by consumers.
Consumers take things, or retire services, or are otherwise in demand by producers.

Let's start with the assumption that each producer produces one thing, and each consumer consumes one thing.
As we'll see, this constraint is not too hard to relax later on, but let's start as simple as possible.
This constrains our answers: we want to match up producers and consumers, but without oversubscribing either.

Let's also imagine that each producer has a preference for each consumer, and each consumer has a (potentially very different) preference for each producer.
We not only want to match up producers and consumers, we want the matching to be somehow "good".
There are many ways to do this, but let's use [stable matching](https://en.wikipedia.org/wiki/Stable_marriage_problem) as the goal: no producer and consumer should want both want to pair up together more than they like the pairing we provide them.

We are now well into "algorithms land", but it turns out Materialize's recursive SQL will work out great here. 
Let's get going on modeling our data, and building up some queries!

### Stable Matching in SQL

We will work off of a table `prefs` that will store the mutual preferences between pairs of producer and consumer.
We'll just call producers and consumers `name1` and `name2`, respectively, which isn't very evocative but easier to type.
We'll also use integer "preferences" where smaller numbers are better; think "which place would this option be" perhaps.

```sql
-- Each entry indicates a potential connection between name1 and name2.
-- Each has a numerical preference for this, where we'll take smaller to be better.
-- The goal is to match up (name1, name2) pairs where each prefers the other over
-- any other "stable" pairing (someone else who likes them back enough not to leave).
CREATE TABLE prefs(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT);
```

Of course, we'll want some example preferences to work with.
We'll go larger later in the post, but let's start with some hungry engineers and some food options.
Thematically, let's imagine that each human prefers the foods based on their own tastes, and the food options (restaurants) prefer the humans based on their distance (because each's prices don't vary as a function of the human, but the delivery cost does).

Here's some made up data that will show off what we are trying to do.

```sql
-- Imagine people have a preference for foods that idk is based on its price.
-- Imagine restaurants have a preference for people based on their distance.
-- Imagine an capacity constraint that each restaurant feeds one person.
INSERT INTO prefs VALUES
('frank', 4, 'ramen', 1),   -- frank needs food, and ramen likes him best
('arjun', 1, 'ramen', 3),   -- arjun lovel ramen, but it is unrequited.
('arjun', 3, 'sushi', 4),   -- arjun can tolerate sushi; they prefer him to nikhil.
('nikhil', 1, 'sushi', 5);  -- nikhil is too far away to safely enjoy sushi.
```

If we study the data (and the comments) we will find that one stable matching is 
```
 name1 | pref1 | name2 | pref2 
-------+-------+-------+-------
 arjun |     3 | sushi |     4
 frank |     4 | ramen |     1
(2 rows)
```
Nikhil doesn't get lunch in this story, which is too bad, but is a demonstration of the constraints: not everyone gets what they want.
Arjun also doesn't get what he wants, which is ramen, because if he did then the ramen-ya would hit Frank up and they'd do lunch instead.
It turns out there aren't other stable matchings for this data, but in general there can be many.

How do we arrive at a stable matching?
Fortunately, way back in 1962, [Gale and Shapley proposed](https://web.archive.org/web/20170925172517/http://www.dtic.mil/get-tr-doc/pdf?AD=AD0251958) an algorithm to do just that.
In one variant: each producer proposes to satisfy their favorite consumer, each consumer definitively rejects all but the best proposal, and spurned proposers repeat with their next best options, until rejections stop or they run out of options.

It's pretty much recursion, isn't it? 
And moreover, each of the steps are pretty easy SQL.
Let's write them down!

```sql
-- Iteratively develop proposals and rejections.
WITH MUTUALLY RECURSIVE
    -- Pairings that have yet not been explicitly rejected.
    active(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT) AS (
        SELECT * FROM prefs
        EXCEPT ALL
        SELECT * FROM rejects
    ),
    -- Each `name1` "proposes" to its favorite-est `name2`.
    proposals(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT) AS (
        SELECT DISTINCT ON (name1) *
        FROM active
        ORDER BY name1, pref1, name2, pref2
    ),
    -- Each `name2` tentatively "accepts" the proposal from its favorite-est `name1`
    tentative(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT) AS (
        SELECT DISTINCT ON (name2) *
        FROM proposals
        ORDER BY name2, pref2, name1, pref1
    ),
    -- Proposals that are not accepted become definitively rejected.
    rejects(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT) AS (
        SELECT * FROM rejects
        UNION ALL
        SELECT * FROM proposals
        EXCEPT ALL
        SELECT * FROM tentative
    )
-- The tentative accepts become real accepts!
SELECT * FROM tentative
```

Each of these steps--proposal, tentative acceptance, and rejection--follow the written description up above.
The behavior of the `WITH MUTUALLY RECURSIVE` block is to evaluate each term in order, then repeat from the top, until they stop changing.
It's worth a moment reading and maybe re-reading the SQL to convince yourself that there is at least some relationship to the written plan.

If we run the query, we get the result up above.

```
 name1 | pref1 | name2 | pref2 
-------+-------+-------+-------
 arjun |     3 | sushi |     4
 frank |     4 | ramen |     1
(2 rows)
```

Of course, we could also `SUBSCRIBE` to the query, and then modify the input.
Let's do that, where we introduce the possibility that Frank would happily eat a sandwich instead.

The snapshot we start with is just the answer up above, which is what we expect.
```
1702997600437	 1	arjun	3	sushi	4
1702997600437	 1	frank	4	ramen	1
```
To remind you, or introduce you, `SUBSCRIBE` produces output whose first column is the timestamp of some update event, followed by a change in count (here `1` for both records), followed by payload columns matching what you'd see from a `SELECT` query.

At this point, we'll introduce this new sandwich opportunity, and see what happens
```
materialize=> insert into prefs values ('frank', 2, 'sando', 3);
```
As soon as I press enter, a bunch of changes spill out of the subscription:
```
1702997625810	 1	arjun	1	ramen	3
1702997625810	-1	arjun	3	sushi	4
1702997625810	 1	frank	2	sando	3
1702997625810	-1	frank	4	ramen	1
1702997625810	 1	nikhil	1	sushi	5
```
How do we read this? 
Arjun has a shuffle where he gains a matching with ramen and yields his sushi seat.
Frank switches to a sandwich from ramen.
And Nikhil gets lunch! 
Sushi isn't happy about it, mind you, but lunch occurs for all producers and consumers.

Importantly, there is one timestamp (`1702997625810`), indicating that all five changes happen atomically, at exactly the same moment.
Neither producer nor consumer will be over-committed, even for a moment, on account of Materialize doesn't screw around with consistency and correctness.

### Generalizing Stable Matching

Let's imagine that each producer and consumer have a "capacity": a number of matchings they are able to participate in.
What do we need to change about our process?
Let's introduce tables `producer_capacity` and `consumer_capacity`, which each hold a name and an integer capacity.

```sql
-- Each producer and consumer have an integer number of matches they can participate in.
CREATE TABLE producer_capacity(name TEXT, cap INT);
CREATE TABLE consumer_capacity(name TEXT, cap INT);
```

What we need to tweak about the algorithm is that each producer proposes at their top `cap` opportunities, and each consumer tentatively accepts their top `cap` proposals.

Where above we have fragments that look like so, to pick the top-one opportunity,
```sql
    -- Each `name1` "proposes" to its favorite-est `name2`.
    proposals(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT) AS (
        SELECT DISTINCT ON (name1) *
        FROM active
        ORDER BY name1, pref1, name2, pref2
    ),
```
we'll want to update these to pick the top `cap` opportunities:
```sql
    -- Each `name1` "proposes" to its `cap` favorite-est `name2`.
    proposals(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT) AS (
        SELECT FROM producer_capacity, 
        LATERAL (
            -- pick out the best `cap` opportunities
            SELECT * FROM active
            WHERE active.name1 = producer_capacity.name
            ORDER BY active.pref1
            LIMIT producer_capacity.cap
        )
    ),
```
This is a bit more complicated, but the `LATERAL` join allows us to invoke `LIMIT producer_capacity.cap` rather than a limit by one that `DISTINCT ON` allows.

We'll need to do the same thing for our `tentative` accepts, using `consumer_capacity`.
```sql
    -- Each `name2` tentatively "accepts" the proposal from its favorite-est `name1`
    tentative(name1 TEXT, pref1 INT, name2 TEXT, pref2 INT) AS (
        SELECT lat.* FROM consumer_capacity, 
        LATERAL (
            -- pick out the best `cap` proposals
            SELECT * FROM proposals
            WHERE proposals.name2 = consumer_capacity.name
            ORDER BY proposals.pref2
            LIMIT consumer_capacity.cap
        ) lat
    ),
```

With unit capacities we'll see the same results as before. 
However, let's introduce Nikhil to ramen, which it turns out he likes.
```
materialize=> insert into prefs values ('nikhil', 1, 'ramen', 2);
```
This has some immediate consequences for our subscription to the matching.
I have to admit, I restarted it because I wanted to pick up the new query with capacities, but the new snapshot put us right back where we were before.
```
1703011622743	-1	arjun	1	ramen	3
1703011622743	 1	arjun	3	sushi	4
1703011622743	 1	nikhil	1	ramen	2
1703011622743	-1	nikhil	1	sushi	5
```
This dislodges Arjun, who is now back on the sushi plan, because the ramen folks are fully occupied. 
But only because they are occupied

Let's update their capacity to two, which should give Arjun a seat.
```
materialize=> update consumer_capacity set cap = 2 where name = 'ramen';
```
```
1703011679155	 1	arjun	1	ramen	3
1703011679155	-1	arjun	3	sushi	4
```
And, to rattle things a bit more let's imagine the sandwich shop is sold out and their capacity drops down to zero.
```
materialize=> update consumer_capacity set cap = 0 where name = 'sando';
```
```
1703011883207	-1	arjun	1	ramen	3
1703011883207	 1	arjun	3	sushi	4
1703011883207	-1	frank	2	sando	3
1703011883207	 1	frank	4	ramen	1
```
Poor Arjun is just getting bounced around. 
He decides he really wants some ramen, and offers a cash incentive which updates their preference for him dramatically. 
We'll model this by just tweaking their preference directly.

```
materialize=> update prefs set pref2 = 1 where name1 = 'arjun' and name2 = 'ramen';
```
```
1703012011622	 1	arjun	1	ramen	1
1703012011622	-1	arjun	3	sushi	4
1703012011622	-1	nikhil	1	ramen	2
1703012011622	 1	nikhil	1	sushi	5
```
And Arjun is back on ramen and Nikhil is back on sushi.

### Recursive SQL and Logistics

We've seen an example of using SQL for one problem that shows up in logistics: stable matching (with capacities).
This certainly isn't the only problem in logistics, nor even the most significant, but it is potentially a new use of SQL to solve the problem.
In particular, I hope this was eye-opening about the potential uses of recursive SQL beyond "graph reachability".